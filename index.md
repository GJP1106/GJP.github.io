# 二叉排序树：

## 名称：二叉排序树、二叉搜索树

## 性质：

- 左子树 < 根节点
- 右子树 > 根节点

## 用途: 解决与**排名**相关的检索需求

## 课后练习题：

LeetCode 110  LeetCode 699

## 总结：

### 一、性质

1. 左子树 < 根节点
2. 右子树 > 根节点
3. 中序遍历结果，是一个有序序列
4. 数据结构:就是定义一种性质，并且维护这种性质

### 二、插入操作

1. 插入的新节点，一定会作为叶子节点

### 三、删除操作

1. 删除度为0的节点，直接删除
2. 删除度为1的节点，把【孤儿字树】挂到其父节点上面去
3. 删除度为2的节点，可以转化成删除度为1的节点

对于度为2的节点:

1. 前驱:左子树最大值
2. 后继：右子树最小值

### 四、随堂练习

1. 插入顺序会影响最终的树形结构
2. 不同的树形结构，查找效率不同

平均查找效率：节点查找次数的期望值，$\frac{总次数}{节点数量}$ ，假设每个节点等概率的查找

### 五、扩展内容

1. 二叉排序树的删除代码优化
   - 删除掉处理度为0的代码逻辑，不影响功能效果
2. 如何解决排名相关的检索需求
   1. 修改二叉排序树的结构定义，增加size字段，记录每棵树的节点数量
   2. $k = LS-1$，根节点就是排名第k位的元素
   3. $k \le LS$,排名第K位的元素在左子树中
   4. $k \gt LS,search_k(root->rchild, k-LS-1)$;
3. 解决Top-K问题（找到小于第k位的所有元素）
   1. 根节点就是第k位元素的话，就把左子树中的值全部输出出来
   2. 第k位在左子树中，前k位元素全部都在左子树中
   3. 第k位在右子树中，说明根节点和左子树中的元素，都是前k位元素中的值
4. 二叉排序树和快速排序的关系
   1. 二叉排序树是快速排序在思维逻辑结构层面用的数据结构
   2. **思考1**：快速排序的时间复杂度和二叉排序树建树时间复杂符之间的关系
   3. **思考2**：快速选择算法和二叉排序树之间的关系
   4. 程序=算法+数据结构

所谓算法设计及分析能力：分类讨论及归纳总结能力

# 平衡二叉查找树之AVL树：

## 名称：AVL树

## 性质:

$|H(left) - H(right)| <= 1$

## 优点：

由于对每个节点的左右子树的树高做了限制，所以整棵树不会退化成一个链接

## 一、学习重点

------

1. 平衡二叉排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质
2. 平衡二叉排序树的学习重点，在于平衡条件以及平衡调整的相关学习

## 二、性质

1. 平衡条件：左右子树高度差不超过1

   $|H(left) - H(right)| <= 1$

## 三、课中思考：

1. 高度为H的BS树，所包含的节点数量在什么范围内？

   $H \le size \le 2^H - 1$

2. 高度为H的AVL树，所包含的节点数量在什么范围内？

   $1.5^H \lt size \le 2^H - 1$

3. 节点数n,树高h的关系

   $h = log^n$

4. AVL树改进的是节点数量的下限

5. 树高 = 生命长度，节点数量 = 生命财富，不同的算法，达到的节点数量是不同的

6. 教育提升的是底限，而不是上限，上限取决于能力和运气

## 四、平衡调整策略

1. 发生在回溯阶段的，第一个失衡节点处
2. 理解平衡调整策略的关键在于：分析清楚四种情况下，ABCD四颗子树树高的关系
3. LL：大右旋
4. LR：先小左旋，再大右旋
5. RL，先小右旋，再大左旋
6. RR：大左旋

## 五、代码演示

1. 插入和删除以后，注意重新计算树高字段
2. 引入了NIL阶段，代替了NULL， NULL不可访问，NIL是一个实际节点，可以访问

# 红黑树(上)

## 一、平衡条件

1. 每个节点非黑即红
2. 根节点是黑色
3. 叶节点(NIL)是黑色
4. 如果一个节点是红色，则它的两个子节点都是黑色的
5. 从根节点出发到所有叶节点路径上，黑色节点数量相同

### 平衡条件的认识：

第4、5条条件，注定了红黑树中最长路径是最短路径的长度的2倍

本质上，红黑树也是通过树高来控制平衡的。

红黑树比AVL树树高控制条件要更松散，红黑树在发生节点插入和删数以后，发生调整的概率，比AVL树要更小。

## 二、学习诀窍

1. 理解红黑树的插入调整，要站在==祖父节点==向下进行调整
2. 理解红黑树的删除调整，要站在==父节点==向下进行调整
3. 插入调整，主要就是为了解决双红情况
4. 新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突
5. 把每一种情况，想象成一颗大的红黑树中的局部子树
6. 局部调整的时候，为了不影响全局，调整前后的路径上黑色节点数量相同

## 三、插入策略

1. 叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑
2. 叔叔节点为黑色的时候，参考AVL树的失衡情况，分成$LL,LR,RL,RR$,先参考AVL树的旋转调整策略，然后再修改三元组的颜色，有两种调整策略:红色上浮，红色下沉。
3. 两大类情况，包含8种小情况

## 四、代码演示

1. 插入调整，发生在递归的回溯阶段
2. 插入调整代码中，使用`goto`语句，8行代码，变成了4行
3. 处理根节点一定是黑色，通过代码封装，`insert->__insert`

# 红黑树(下)

## 一、删除调整发生的前提

1. 删除红色节点，不会对红黑树的平衡产生影响
2. 度为1的黑色节点，唯一子孩子，一定是红色
3. 删除度为1的黑色节点，不会产生删除调整
4. 删除度为0的黑色节点，会产生一个双重黑的NIL节点
5. 删除调整，就是为了干掉双重黑

## 二、删除调整

1. 双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色，父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色。

2. 兄弟节点是黑色，并且兄弟节点中有红色子节点

   1. R(兄弟)R(右子节点)-->左旋，新根改成原根的颜色，将新根的两个子节点，改成黑色

      ![image-20201224080041401](C:\Users\GJP\AppData\Roaming\Typora\typora-user-images\image-20201224080041401.png)

   2. R(兄弟)L(左子节点)-->先小右旋，对调新根与原根的颜色，转成上一种情况

      ![image-20201223084542187](C:\Users\GJP\AppData\Roaming\Typora\typora-user-images\image-20201223084542187.png)

   3. LL同理RR

   4. LR同理RL

3. 兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况

![image-20201223084218374](C:\Users\GJP\AppData\Roaming\Typora\typora-user-images\image-20201223084218374.png)

## 三、代码演示

1. 进行LR/RL类型判断的时候，不能判断LL子树是否为黑色，LL子树有可能是NIL节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL子树不是红色】。

# 哈夫曼树与哈夫曼编码

## 一、课程节奏

1. 直观的了解哈夫曼树与哈夫曼编码
2. 证明：哈夫曼编码是最优的变长编码

## 二、前置知识

1. 什么是编码

   'a' = 97 = $(0110\ 0001)_2$

   '0' = 48 = $(0011\ 0000)_2$

   注意：任何信息，在计算机中，都是二进制存储的

   信息："aa00" = $01100001、01100001、00110000、00110000$

   一台计算机  传输到 另外一台计算机，传输32个比特位

   假设：计算机的网络是32bit/s，所以用时:$1s$

   特定场景:只有a, b, 0, 1四种字符需要传输

   a:00,b:01,0:10,1:11

   "aa00" = 00001010

   假设在带宽不变的情况下，当前只需要传输0.25s

2. 定长与变长编码

   1. Ascii编码 和 特定场景下的海贼班编码，都属于定长编码
   2. 对于每一个字符，编码长度不同，这就是定长编码
   3. 【大家自行补充】UTF-8编码，是变长编码，UTF-16,是定长编码
   4. 对于每一个字符，编码长度不相同，这就是变长编码
   5. 将定长编码，看成是变长编码的特例
   6. 变长编码，一定不差于定长编码

### 变长编码应用场景

特定场景：

1. 只有四种字符:ab01

2. 出现概率：a:0.8,b:0.05,0:0.1,1:0.05

   平均编码长度:

   $l_i$:第i种字符，编码长度

   $p_i$:第i种字符，出现概率

   $avg(l) = \sum{l_i \times p_i}$

   假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位

   海贼班编码的平均编码长度：$avg(l) = 2\times\sum{p_i} = 2$

   新·海贼班编码：a: 1,b: 01, 0: 000, 1: 001

   平均编码长度:$1*0.8+2*0.05+3*0.1+3*0.05 = 1.35$

   100个字符，需要135个比特位

## 三、哈弗曼编码

1. 首先，统计得到每一种字符的概率
2. 将n个字符，建立成一棵哈弗曼树
3. 每一个字符，都落在叶子结点上
4. 按照左0，右1的形式，将编码读取出来

得到新编码：

a:0 | b: 110 | 0：10|1：111

平均编码长度:$1*0.8+3*0.05+2*0.1+3*0.05 = 1.3$

结论：哈夫曼编码，是最优的变长编码

## 四、公式证明

1. 首先表示平均编码长度，求解公式最优解

   每个结点覆盖的叶子结点数为:$2^{H-l_i}$

   证明：$\sum{p_i · l_i}$最小

   总的覆盖数为:

   $2^{H-l_1} + 2^{H-l_2} + 2^{H-l_3} +2^{H-l_4}...2^{H-l_n} \le 2^H $

   两边同除以$2^H$:

   $\frac{1}{2^{l_1}} + \frac{1}{2^{l_2}} + \frac{1}{2^{l_3}} +...+ \frac{1}{2^{l_n}} \le 1 $

   设${l_i}^` = -l_i$:

   $2^{{l_1}^`} + 2^{{l_2}^`} + 2^{{l_3}^`} +2^{{l_4}^`}+...+2^{{l_n}^`} \le 1 $

   上述证明转化为：证明：$-\sum{p_i · {{l_i}^`}}$最小

   约束：$\sum2^{{l_i}^`} \le 1$

   设：$I_i = 2^{{l_i}^`}$--> ${l_i}^` = {log_2}^{I_i}$ 

   约束条件变为:$\sum I_i \le 1$

   目标转化为:$-\sum p_i · {log_2}^{I_i}$ 最小

   当目标函数达到最小时：$\sum I_i = 1$

   反证法：$1 - \sum I_i = {I_x}^`$

   $p_i·log_{2^{({I_i+{I_x}^`})}}$ 会使目标变小，故目标最优时，${I_x}^` = 0$

   熵的公式:$-\sum p_i log{p_i}$

   熵代表一个系统中的平均编码长度，熵越大，平均编码长度越长

2. 最终，和熵与交叉熵之间的关系

# 线段树

## 一、问题背景

1. 单点修改，区间查询(基础版本)
2. 区间修改，区间查询(进阶版)
3. 单点修改，单点查询(用不着线段树)
4. 区间修改，单点查询(是第二种情况的特例)

## 二、基础版线段树

1. 线段树是对于一维序列的一种维护结构
2. 采用分治的思想，将总区间分成左右两部分，一直进行下去，直到区间中只剩下一个结点为止
3. 线段树的叶子结点，代表了原序列中的单个位置的值
4. 如果采用完全二叉树的存储结构的话，最起码需要$4n$的存储空间
5. 当面对区间修改的时候，基础版的线段树效率熵还不如直接在一维序列上修改
6. 只适用于单点修改，区间查询

### 练习题：OJ222. 练习题1：线段树模板(一)

#### 题目描述

 给定一个 n 位数组和两种操作:

 **操作1：**修改数组中某个位置的值

 **操作2：**查询数组中某个区间的最大值

------

#### 输入

 第一行输入两个整数 n,m(1≤n≤10000，3≤m≤100000)，分别代表数组大小和操作数。

 第二行包含 n 个整数，代表数组中相应的数字，数字大小不会超过 int 表示范围。

 接下来 m 行，每行三个整数 a,b,c（a∈[1,2])

1. 当 a=1 时，代表将数组 b 位置上的值修改成 c，(1≤b≤n, c is int)
2. 当 a=2 时，代表询问 [b,c][b,c] 区间内的最大值 ( 1≤b,c≤n)，当 b>c 时，输出：-2147483648

#### 输出

 对于每个 a=2的操作，输出查询区间内的最大值。

------

#### 样例输入

```
6 5
6 9 4 3 2 1
2 2 5
1 2 3
2 1 6
1 5 12
2 1 6
```

#### 样例输出

```
9
6
12
```

------

#### 数据规模与约定

时间限制：1 s

内存限制：64 M

100% 的数据保证n,m(1≤n≤10000，3≤m≤100000)

### 代码演示：OJ222

## 三、进阶版线段树

1. 优化掉了代码实现中的:l, r。区间变量
2. 可以用于区间更新，区间查询
3. 增加了懒标记，达到能够区间更新的目的
4. 懒标记是需要向下下沉的
5. 标记下沉发生在递归之前，向上更新发生在具有修改操作的递归之后

# 从递推到动归(一)

## 一、递推问题的求解套路

1. 确定递推状态：一个数学符号 + 一个数学符号的语义解释
2. 确定递推公式：推导递推状态符号的自我表示方法
3. 程序实现，(递归+记忆化)、(循环实现)

### 确定递推状态：

注意：这是学习递推问题的重中之重。学习确定递推状态的技巧。

$f(x) = y$

y : 问题中的求解量，也是我们所谓的因变量

x: 问题中直接影响求解量的部分，也是我们所谓的自变量

本质:就是寻找问题中的自变量与因变量

### 确定递推公式：

本质：分析状态中的容斥关系

$f(n) = f(n - 1) + f(n - 2)$

$f(n - 1), 代表n-1个月兔子数量，恰巧等于第n个月的成年兔子数量$

$f(n - 2), 代表n-2个月兔子数量，恰巧等于第n个月的幼年兔子数量$

所谓的推导，就是推导上面这两句话的内容

# 从递推到动归(二)

## 一、数字三角形

### 惊人的发现

$f(i, j)$代表从底边走到i，j点的最大值

$f(i, j)$代表从顶点走到i，j点的最大值

1. 数学符号完全一致
2. 语义信息不同
3. 递归公式不同
4. 结论：数学符号无法完全代表状态定义

### 两种方法的对比

本质：两种状态定义方式的对比

1. 第一种：不用做边界判断，最终结果，直接存储在$f[0][0]$
2. 第二种：需要做边界判断，最终结果，存储在一组数据中
3. 结论：第一种要比第二种优秀

## 二、动态规划问题的求解套路

1. 第一步：确定动归状态
2. 第二步：推导状态转移方程，理解：转移，决策
3. 第三步：正确性证明，利用数学归纳法
4. 第四步：程序实现
5. 所谓的转移，把所有决定f(i,j)最优值的状态，放入到决策过程中。

## 三、附加内容：拓扑序

图形结构是最最抽象的数据结构，必须理解成思维逻辑结构

1. 拓扑序是一种树形结构上的依赖顺序，一个图的拓扑序不唯一
2. 拓扑序的本质作用：是把图形结构上变成一个一维序列
3. 图形结构不能用循环遍历的，一维序列可以
4. 所有递推问题中的状态更新过程，本质上满足拓扑序

## 四、最长上升子序列

### 状态定义

$f(i)$代表以i为结尾的，最长上升子序列的长度

### 状态转移方程

$f(i) = max\lbrace{f(j) \rbrace } + 1 | j < i, val[j] < val[i]$

状态转移的时间复杂度:$O(n^2)$

后续重点：优化转移过程

$\left\{\begin{aligned}x&=1\\y&=2+x\end{aligned}\right.$

## 五、最长公共子序列

### 状态定义

$f(i, j)$代表第一个字符串取前i位，第二个字符串取前j位，最长公共子序列的长度

### 状态转移方程

$f(i,j) = \left\{\begin{aligned} & max\lbrace{f(i - 1, j), f(i, j - 1)\rbrace} &val(i) \neq val(j)\\ & f(i - 1, j - 1) &val(i) = val(j)\end{aligned} \right.$

状态转移的时间复杂度:$O(n \times m)$

学习重点：注意到，参与决策的状态数量，是会根据条件不同而改变的

## 六、课后作业

1. **HZOJ46[切割回文]**
2. **HZOJ47-0/1背包**
3. **HZOJ48-完全背包**
4. **HZOJ49-多重背包**


